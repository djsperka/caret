Description: Compatibility with VTK 5.2+
 Caret assumes vtkIdType to be int32. For recent VTK version this is not true
 on 64bit systems. This patch make caret compile on such systems. It needs more
 testing to verify that it doesn't break things, but initial reports are
 promising.
Author: Michael Hanke <michael.hanke@gmail.com>
Last-Update: 2010-04-08
--- a/caret_brain_set/BrainModelContourToSurfaceConverter.cxx
+++ b/caret_brain_set/BrainModelContourToSurfaceConverter.cxx
@@ -143,7 +143,7 @@
          continue;
       }
             
-      int* verts = new int[numPoints];
+      vtkIdType* verts = new vtkIdType[numPoints];
 
       if (lastSectionNumberValid) {
          if (sectionNumber != lastSectionNumber) {
@@ -166,7 +166,9 @@
                    << ", VTK-section=" << vtkSectionNumber << std::endl;
       }
       
-      int pointCount = 0;
+      // this used to be an int.. is this still good now that it is a
+      // vtkIdType?
+      vtkIdType pointCount = 0;
       for (int j = 0; j < numPoints; j++) {
          float x, y;
          cc->getPointXY(j, x, y);
--- a/caret_brain_set/BrainModelSurface.cxx
+++ b/caret_brain_set/BrainModelSurface.cxx
@@ -1169,9 +1169,14 @@
          int size = cells->EstimateSize(numTiles, 3);
          cells->Allocate(size, 25);
          for (int j = 0; j < numTiles; j++) {
+            // this is ridiculus, I know
+            vtkIdType v_vtk[3];
             int v[3];
             topology->getTile(j, v[0], v[1], v[2]);
-            cells->InsertNextCell(3, v);
+            v_vtk[0] = v[0];
+            v_vtk[1] = v[1];
+            v_vtk[2] = v[2];
+            cells->InsertNextCell(3, v_vtk);
          }
          
          vtkPolyData* polyData = vtkPolyData::New();
@@ -1320,8 +1325,8 @@
       vtkCellArray* cells = polyData->GetPolys();
       if (cells->GetNumberOfCells() == numTiles) {
          int cellID = 0;
-         int npts;
-         int* pts;
+         vtkIdType npts;
+         vtkIdType* pts;
          for (cells->InitTraversal(); cells->GetNextCell(npts, pts); cellID++) {
             if (npts == 3) {
                int verts[3];
--- a/caret_brain_set/BrainModelVolumeToSurfaceConverter.cxx
+++ b/caret_brain_set/BrainModelVolumeToSurfaceConverter.cxx
@@ -317,9 +317,9 @@
       decimater->SetErrorIsAbsolute(1);
       
       if (DebugControl::getDebugOn()) {
-         decimater->PrintSelf(std::cout, 3);
+         decimater->PrintSelf(std::cout, static_cast<vtkIndent>(3));
          decimater->Update();
-         decimater->PrintSelf(std::cout, 3);
+         decimater->PrintSelf(std::cout, static_cast<vtkIndent>(3));
          vtkPolyDataWriter* writer = vtkPolyDataWriter::New();
          writer->SetInput(decimater->GetOutput());
          writer->SetFileName("surface_decimated.vtk");
--- a/caret_files/TopologyFile.cxx
+++ b/caret_files/TopologyFile.cxx
@@ -1395,8 +1395,8 @@
    std::vector<int> triangles;
    
    vtkCellArray* polys = polyData->GetPolys();
-   int npts;
-   int* pts;
+   vtkIdType npts;
+   vtkIdType* pts;
    for (polys->InitTraversal(); polys->GetNextCell(npts,pts); ) {
       if (npts == 3) {
          triangles.push_back(pts[0]);
--- a/caret_files/TopologyHelper.cxx
+++ b/caret_files/TopologyHelper.cxx
@@ -185,8 +185,8 @@
    
    if (buildNodeInfo) {
       vtkCellArray* polys = vtk->GetPolys();
-      int npts;
-      int* pts;
+      vtkIdType npts;
+      vtkIdType* pts;
       const int maxNodeNum = vtk->GetNumberOfPoints();  //-1;
       for (polys->InitTraversal(); polys->GetNextCell(npts,pts); ) {
          if (npts != 3) {
@@ -216,8 +216,8 @@
    //
    vtkCellArray* polys = vtk->GetPolys();
    int cellId = 0;
-   int npts;
-   int* pts;
+   vtkIdType npts;
+   vtkIdType* pts;
    for (polys->InitTraversal(); polys->GetNextCell(npts,pts); cellId++) {
       if (npts != 3) {
          std::cerr << " Polygon is not a triangle in TopologyHelper"      
--- a/caret_files/VtkModelFile.cxx
+++ b/caret_files/VtkModelFile.cxx
@@ -105,7 +105,7 @@
       const Border* border = bf->getBorder(i);
       const int numLinks = border->getNumberOfLinks();
       if (numLinks > 0) {
-         std::vector<int> pts;
+         std::vector<vtkIdType> pts;
          for (int j = 0; j < numLinks; j++) {
            unsigned char rgbaColor[4] = { 170, 170, 170, 255 };
            const int colorIndex = border->getBorderColorIndex();
@@ -468,8 +468,8 @@
    const int numVertices = polyData->GetNumberOfVerts();
    if (numVertices > 0) {
       vtkCellArray* verts = polyData->GetVerts();
-      int npts;
-      int* pts;
+      vtkIdType npts;
+      vtkIdType* pts;
       for (verts->InitTraversal(); verts->GetNextCell(npts, pts); ) {
          for (int i = 0; i < npts; i++) {
             vertices.push_back(pts[i]);
@@ -483,8 +483,8 @@
    const int numLines = polyData->GetNumberOfLines();
    if (numLines > 0) {
       vtkCellArray* cellLines = polyData->GetLines();
-      int npts;
-      int* pts;
+      vtkIdType npts;
+      vtkIdType* pts;
       for (cellLines->InitTraversal(); cellLines->GetNextCell(npts, pts); ) {
          lines.push_back(VtkModelObject(pts, npts));
       }
@@ -496,8 +496,8 @@
    vtkCellArray* polys = polyData->GetPolys();
    const int numPolys = polyData->GetNumberOfPolys();
    if (numPolys > 0) {
-      int npts;
-      int* pts;
+      vtkIdType npts;
+      vtkIdType* pts;
       for (polys->InitTraversal(); polys->GetNextCell(npts,pts); ) {
          if (npts == 3) {
             triangles.push_back(pts[0]);
@@ -763,7 +763,8 @@
       //polysVTK->Allocate(size, 25);
       for (int j = 0; j < numTriangles; j++) {
          const int* v = getTriangle(j);
-         polysVTK->InsertNextCell(3, (int*)v);
+         // wild casting is evil
+         polysVTK->InsertNextCell(3, (vtkIdType*)v);
       }
    }
    const int numPolys = getNumberOfPolygons();
@@ -773,8 +774,9 @@
       }
       for (int j = 0; j < numPolys; j++) {
          const VtkModelObject* vmo = getPolygon(j);
-         polysVTK->InsertNextCell(vmo->getNumberOfItems(),
-                                  (int*)vmo->getPointIndex(0));
+         // wild casting is evil
+         polysVTK->InsertNextCell(static_cast<vtkIdType>(vmo->getNumberOfItems()),
+                                  (vtkIdType*)(vmo->getPointIndex(0)));
       }
    }
    
@@ -789,7 +791,8 @@
       for (int j = 0; j < numLines; j++) {
          const VtkModelObject* vmo = getLine(j);
          const int* pts = vmo->getPointIndex(0);
-         linesVTK->InsertNextCell(vmo->getNumberOfItems(), (int*)pts);
+         // wild casting is evil
+         linesVTK->InsertNextCell(vmo->getNumberOfItems(), (vtkIdType*)pts);
       }
    }
    
@@ -801,7 +804,8 @@
    if (numVerts > 0) {
       vertsVTK = vtkCellArray::New();
       for (int j = 0; j < numVerts; j++) {
-         vertsVTK->InsertNextCell(1, (int*)getVertex(j));
+         // wild casting is evil
+         vertsVTK->InsertNextCell(1, (vtkIdType*)getVertex(j));
       }
    }
    
--- a/caret_files/VtkModelFile.h
+++ b/caret_files/VtkModelFile.h
@@ -31,6 +31,8 @@
 #include "AbstractFile.h"
 #include "CoordinateFile.h"
 
+#include "vtkCellArray.h" // bayle added mb
+
 class BorderColorFile;
 class BorderFile;
 class CellColorFile;
@@ -46,7 +48,7 @@
       class VtkModelObject {
          public:
             /// Constructor
-            VtkModelObject(const int* ptsIn, const int numPtsIn) {
+            VtkModelObject(const vtkIdType* ptsIn, const vtkIdType numPtsIn) {
                for (int i = 0; i < numPtsIn; i++) {
                   pts.push_back(ptsIn[i]);
                }
